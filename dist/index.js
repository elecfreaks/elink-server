var j=Object.create;var S=Object.defineProperty;var z=Object.getOwnPropertyDescriptor;var F=Object.getOwnPropertyNames;var G=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var q=c=>S(c,"__esModule",{value:!0});var Q=(c,r)=>{for(var t in r)S(c,t,{get:r[t],enumerable:!0})},U=(c,r,t,e)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of F(r))!K.call(c,i)&&(t||i!=="default")&&S(c,i,{get:()=>r[i],enumerable:!(e=z(r,i))||e.enumerable});return c},v=(c,r)=>U(q(S(c!=null?j(G(c)):{},"default",!r&&c&&c.__esModule?{get:()=>c.default,enumerable:!0}:{value:c,enumerable:!0})),c),X=(c=>(r,t)=>c&&c.get(r)||(t=U(q({}),r,1),c&&c.set(r,t),t))(typeof WeakMap!="undefined"?new WeakMap:0);var _={};Q(_,{startElinkServer:()=>Z});var M=require("http"),H=require("ws"),P=v(require("electron-log"));var w=v(require("@abandonware/noble")),f=v(require("electron-log"));var y=v(require("electron-log"));var L=v(require("electron-log")),p=class{constructor(r,t,e){this.code=r,this.message=t,this.data=e}toError(){let r=`JSONRPCError: {code: ${this.code}, message: ${this.message}, data: ${this.data}}`;return L.default.error(r),new Error(r)}static parseError(r){return new p(-32700,"Parse Error",r)}static invalidRequest(r){return new p(-32600,"Invalid Request",r)}static methodNotFound(r){return new p(-32601,"Method Not Found",r)}static invalidParams(r){return new p(-32602,"Invalid Params",r)}static internalError(r){return new p(-32603,"Internal Error",r)}static serverError(r,t){return new p(r,"Server Error",t)}static applicationError(r){return new p(-32500,"Application Error",r)}},n=p;var J=class{constructor(r){this.NetworkProtocolVersion="1.2";this.nextId=0;this.completionHandlers={};this.socket=r,this.onMessage=this.onMessage.bind(this),this.socket.on("message",this.onMessage)}dispose(){this.socket&&(this.socket.off("message",this.onMessage),this.socket.close()),this.socket=null,this.completionHandlers={}}async didReceiveCall(r,t,e){switch(r){case"pingMe":e("willPing"),this.sendRemoteRequest("ping",null,(i,s)=>{y.default.info(`Got result from ping: ${i}, error: ${s}.`)});break;case"getVersion":e(this.getVersion());break;default:throw e(null,n.methodNotFound(r)),n.methodNotFound(r).toError()}}getVersion(){return{protocol:this.NetworkProtocolVersion}}sendRemoteRequest(r,t,e){var s;let i={jsonrpc:"2.0",method:r};if(t&&(i.params=t),e){let o=this.getNextId();i.id=o,this.completionHandlers[o]=e}try{(s=this.socket)==null||s.send(JSON.stringify(i))}catch(o){y.default.error(`Error serializing or sending request: ${o}.`),y.default.error(`Request was: ${JSON.stringify(i)}.`)}}onMessage(r){this.didReceiveMessage(r,t=>{this.socket&&this.socket.send(JSON.stringify(t))})}makeResponse(r,t,e){let i={id:r,jsonrpc:"2.0"};return e?i.error=e:i.result=t,i}didReceiveMessage(r,t){let e=JSON.parse(r.toString()),i=(s,o)=>{try{let a=this.makeResponse(e.id,s,o);t(a)}catch{let l=this.makeResponse(e.id,null,n.applicationError("Could not encode response"));t(l)}};try{if(e.jsonrpc!=="2.0")throw n.invalidRequest("unrecognized JSON-RPC version string").toError();if(e.method)this.didReceiveRequest(e,(s,o)=>i(s,o));else if(e.result||e.error)this.didReceiveResponse(e);else throw n.invalidRequest("message is neither request nor response").toError()}catch(s){i(null,n.applicationError(`Unhandled error encountered during call: ${s}`))}}didReceiveRequest(r,t){let{method:e,params:i}=r;if(e===""||typeof e!="string")throw n.invalidRequest("method value missing or not a string").toError();this.didReceiveCall(e,i||{},t)}didReceiveResponse(r){let{id:t,error:e,result:i}=r;if(!t)throw n.invalidRequest("response ID value missing or wrong type").toError;let s=this.completionHandlers[t];if(!s)throw n.invalidRequest("response ID does not correspond to any open request").toError();try{e?s(null,e):s(i)}catch{throw n.applicationError(`exception encountered while handling response ${t}`).toError()}}getNextId(){return this.nextId++}},R=J;var g=(i=>(i[i.Include=0]="Include",i[i.ExcludeReads=1]="ExcludeReads",i[i.ExcludeWrites=2]="ExcludeWrites",i[i.Exclude=3]="Exclude",i))(g||{}),N=class{static isServiceUUID(r){return typeof r=="string"||typeof r=="number"}static isUUID(r){return typeof r=="string"}static getBlockListStatus(r){return N.BlockList[r]??0}static getUUID(r){return typeof r=="number"?r.toString(16).padStart(4,"0"):r.length===4||r.includes("-")?r.toLowerCase():`${r.slice(0,8)}-${r.slice(8,12)}-${r.slice(12,16)}-${r.slice(16,20)}-${r.slice(20,32)}`.toLowerCase()}},d=N;d.BlockList={"00001812-0000-1000-8000-00805f9b34fb":3,"00001530-1212-efde-1523-785feabcd123":3,"f000ffc0-0451-4000-b000-000000000000":3,"00060000-0000-1000-8000-00805f9b34fb":3,"0000fffd-0000-1000-8000-00805f9b34fb":3,"00002a02-0000-1000-8000-00805f9b34fb":2,"00002a03-0000-1000-8000-00805f9b34fb":3,"00002a25-0000-1000-8000-00805f9b34fb":3,"00002902-0000-1000-8000-00805f9b34fb":2,"00002903-0000-1000-8000-00805f9b34fb":2};var C=class extends R{constructor(r){super(r);this.filters=null;this.services=[];this.reportedPeripherals=new Map;this.peripheral=null;this.allowedServices=null;this.discoverTimeout=null;this.cachedCharacteristics={};this.cachedServiceCharacteristics={};this.notifyCharacteristics=new Map;this.discoverListener=this.discoverListener.bind(this),this.onValueChanged=this.onValueChanged.bind(this)}dispose(){this.stopDiscover(),this.notifyCharacteristics.forEach(r=>{r.unsubscribe(),r.removeAllListeners("data")}),this.notifyCharacteristics.clear(),this.services=[],this.peripheral&&(this.peripheral.disconnect(),this.peripheral=null),super.dispose()}async didReceiveCall(r,t,e){switch(r){case"discover":try{await this.discover(t),e(null)}catch(i){e(null,i)}break;case"connect":try{await this.connect(t),e(null)}catch(i){e(null,i)}break;case"write":try{let i=await this.write(t);e(i)}catch(i){e(null,i)}break;case"read":try{let i=await this.read(t);e(i)}catch(i){e(null,i)}break;case"startNotifications":try{await this.startNotifications(t),e(null)}catch(i){e(null,i)}break;case"stopNotifications":try{await this.stopNotifications(t),e(null)}catch(i){e(null,i)}break;case"getServices":e(this.services.map(i=>d.getUUID(i.uuid)));break;default:super.didReceiveCall(r,t,e);break}}async discover(r){if(this.services.length)throw n.invalidRequest("cannot discover when connected").toError();let{filters:t,optionalServices:e}=r;if(!Array.isArray(t)||t.length<1)throw n.invalidParams("discovery request must include filters").toError();let i=t.map(a=>new B(a));if(i.findIndex(a=>a.isEmpty())!==-1)throw n.invalidParams("discovery request includes empty filter").toError();let s=[];Array.isArray(e)&&(s=e.map(a=>d.getUUID(a)));let o=s;i.forEach(a=>{let l=a.requiredServices;l&&(o=[...o,...l])}),this.filters=i,this.allowedServices=o,this.reportedPeripherals.clear(),this.peripheral=null,w.default.on("discover",this.discoverListener),this.discoverTimeout=setTimeout(()=>{this.stopDiscover()},C.DiscoverTime);try{await w.default.startScanningAsync([])}catch(a){throw n.applicationError(`failed to start scanning: ${a}`).toError()}f.default.info("BLE start discover.")}async stopDiscover(){try{await w.default.stopScanningAsync()}catch(r){f.default.error(r)}w.default.removeListener("discover",this.discoverListener),this.discoverTimeout&&(clearTimeout(this.discoverTimeout),this.discoverTimeout=null),f.default.info("BLE stop discover.")}discoverListener(r){var o;let{id:t,rssi:e,advertisement:i}=r;if(e<C.MinimumSignalStrength||!((o=this.filters)==null?void 0:o.every(a=>a.matches(i))))return;let s={peripheralId:t,name:i.localName,rssi:e};this.reportedPeripherals.set(t,r),this.sendRemoteRequest("didDiscoverPeripheral",s),f.default.info(`BLE discovered peripheral -> {id: ${t}, rssi: ${e}}.`)}async connect(r){var e,i,s;if(await this.stopDiscover(),this.services.length)throw n.invalidRequest("already connected to peripheral").toError();let t=r.peripheralId;if(!t)throw n.invalidParams("missing or invalid peripheralId").toError();if(!this.reportedPeripherals.has(t))throw n.invalidParams(`invalid peripheralId: ${t}`).toError();try{await((e=this.reportedPeripherals.get(t))==null?void 0:e.connectAsync()),this.peripheral=this.reportedPeripherals.get(t)??null,this.services=await((i=this.peripheral)==null?void 0:i.discoverServicesAsync())??[];let{characteristics:o}=await((s=this.peripheral)==null?void 0:s.discoverAllServicesAndCharacteristicsAsync())??{};o==null||o.forEach(a=>{this.cachedCharacteristics[d.getUUID(a.uuid)]=a}),f.default.info(`BLE peripheral {id: ${t}} is connected.`)}catch(o){throw n.applicationError(`failed to connect: ${o}`).toError()}}async write(r){let t=await this.getEndpoint("write request",r,g.ExcludeWrites),{message:e,encoding:i,withResponse:s}=r,o=Buffer.from(e,i);try{return await t.writeAsync(o,s),o.length.toString()}catch(a){throw n.applicationError(`failed to write: ${a}`).toError()}}async read(r){let t=await this.getEndpoint("read request",r,g.ExcludeReads),e=r.encoding?r.encoding.toString():"base64";try{let i=await t.readAsync(),{startNotifications:s}=r;return s&&await this.startNotificationsByEndpoint(t,e),i.toString(e)}catch(i){throw n.applicationError(`failed to read: ${i}`).toError()}}async startNotifications(r){let t=await this.getEndpoint("startNotifications request",r,g.ExcludeReads),e=r.encoding?r.encoding.toString():"base64";await this.startNotificationsByEndpoint(t,e)}async startNotificationsByEndpoint(r,t){r.on("data",e=>this.onValueChanged(r,e,t));try{await r.subscribeAsync(),f.default.info(`Start notification on characteristic: ${r.uuid}.`)}catch(e){throw n.applicationError(`failed to start notifications: ${e}`).toError()}}onValueChanged(r,t,e){let i={serviceId:d.getUUID(r._serviceUuid),characteristicId:d.getUUID(r.uuid),encoding:e,message:t.toString(e)};this.sendRemoteRequest("characteristicDidChange",i)}async stopNotifications(r){let t=await this.getEndpoint("startNotifications request",r,g.ExcludeReads);try{await t.unsubscribeAsync(),t.removeAllListeners("data"),f.default.info(`Stop characteristic: ${t.uuid} notifications.`)}catch(e){throw n.applicationError(`failed to stop notifications: ${e}`).toError()}}async getEndpoint(r,t,e){var h,m;let i,s;if(((h=this.peripheral)==null?void 0:h.state)!=="connected")throw n.applicationError(`peripheral is not connected for ${r}`).toError();if(t.serviceId?(s=d.getUUID(t.serviceId),i=this.services.find(u=>d.getUUID(u.uuid)===s)):(i=this.services[0],s=d.getUUID(i.uuid)),!s)throw n.invalidParams(`could not determine service UUID for ${r}`).toError();if(!((m=this.allowedServices)==null?void 0:m.includes(s)))throw n.invalidParams(`attempt to access unexpected service: ${s}`).toError();let o=d.getBlockListStatus(s);if(o===e||(o^e)===((e^15)&3))throw n.invalidParams(`service is block-listed with ${o}: ${s}`).toError();if(!i)throw n.invalidParams(`could not find service ${s}`).toError();let a,l;if(t.characteristicId)l=d.getUUID(t.characteristicId);else{let u=this.cachedServiceCharacteristics[s];if(!u)try{u=await i.discoverCharacteristicsAsync(),this.cachedServiceCharacteristics[s]=u}catch(I){throw n.applicationError(`failed to collect characteristics from service: ${I}`).toError()}a=u[0],l=a?d.getUUID(a.uuid):""}if(!l)throw n.invalidParams(`could not determine characteristic UUID for ${r}`).toError();if(o=d.getBlockListStatus(l),o===e||(o^e)===((e^15)&3))throw n.invalidParams(`characteristic is block-listed with ${o}: ${l}`).toError();if(!a&&(a=this.cachedCharacteristics[l]),!a){f.default.info("collect the characteristic if we didn't do so above");try{if(a=(await i.discoverCharacteristicsAsync()).find(u=>d.getUUID(u.uuid)===l),!a)throw n.invalidParams(`could not find characteristic ${l} on service ${s}`).toError();this.cachedCharacteristics[l]=a}catch(u){throw n.applicationError(`failed to collect characteristics from service: ${u}`).toError()}}return a}},b=C;b.DiscoverTime=15e3,b.MinimumSignalStrength=-70;var B=class{constructor(r){let{name:t,namePrefix:e,services:i,manufacturerData:s}=r;if(this.name=t,this.namePrefix=e,Array.isArray(i)&&(this.requiredServices=i.map(o=>{if(d.isServiceUUID(o))return d.getUUID(o);throw n.invalidParams(`could not determine UUID for service ${o}`).toError()})),s){this.manufacturerData={};for(let o in s)if(s.hasOwnProperty(o)&&!isNaN(Number(o))){let{dataPrefix:a,mask:l=[]}=s[o];if(!a||!Array.isArray(a))throw n.invalidParams("no data prefix specified").toError();if(Array.isArray(l)&&l.length===0)for(let h=0;h<a.length;h++)l.push(255);if(!Array.isArray(l)||a.length!==l.length)throw n.invalidParams("length of data prefix does not match length of mask").toError();this.manufacturerData[o]={dataPrefix:a.map(h=>parseInt(h)),mask:l.map(h=>parseInt(h))}}}}matches(r){let{localName:t,serviceUuids:e,manufacturerData:i}=r;if(this.name&&this.name!==t||this.namePrefix&&(!t||t.indexOf(this.namePrefix)!==0))return!1;if(this.requiredServices){let s=(e==null?void 0:e.map(o=>d.getUUID(o)))??[];if(!this.requiredServices.every(o=>s.includes(o)))return!1}if(this.manufacturerData){for(let s in this.manufacturerData)if(this.manufacturerData.hasOwnProperty(s)){let{dataPrefix:o,mask:a}=this.manufacturerData[s];if(!o||!a)return!1;let l=o.map((m,u)=>m&a[u]),h=(i==null?void 0:i.toJSON().data)??[];if(h.length>2){let m=h[0]|h[1]<<8,I=h.slice(2,2+a.length).map((k,D)=>k&a[D]);if(m!==parseInt(s)||!l.every((k,D)=>k===I[D]))return!1}else return!1}}return!0}isEmpty(){return!!this.name&&!!this.namePrefix&&!!this.requiredServices&&!!this.manufacturerData}},A=b;var x=v(require("serialport")),E=v(require("electron-log"));var $=class extends R{constructor(r){super(r);this.reportedPorts=new Map;this.port=null;this.discoverTimeout=null;this.listPortInterval=null}dispose(){var r;this.stopDiscover(),this.stopListen(),((r=this.port)==null?void 0:r.isOpen)&&this.port.close(t=>{t&&E.default.error(`Serial port close error: ${t.message}.`)}),this.port=null,super.dispose()}async didReceiveCall(r,t,e){switch(r){case"discover":try{await this.discover(t),e(null)}catch(i){e(null,i)}break;case"connect":try{await this.connect(t),e(null)}catch(i){e(null,i)}break;case"write":try{await this.write(t),e(null)}catch(i){e(null,i)}break;case"read":e(this.read(t));break;case"listen":this.listen(),e(null);break;case"stopListen":this.stopListen(),e(null);break;default:super.didReceiveCall(r,t,e);break}}async discover(r){let{filter:t}=r;if(!t)throw n.invalidParams("discovery request must include filter").toError();E.default.info("Serial port start discover."),this.port=null,this.listPort(t),this.listPortInterval=setInterval(()=>{this.listPort(t)},1e3),this.discoverTimeout=setTimeout(()=>{this.stopDiscover()},$.DiscoverTime)}async listPort(r){this.reportedPorts.clear(),(await x.default.list()).forEach(e=>{var s,o;if(e.path==="COM1"||e.path.includes("Bluetooth-Incoming-Port")||r.vendorId&&r.vendorId.toLowerCase()!==((s=e.vendorId)==null?void 0:s.toLowerCase())||r.productId&&r.productId.toLowerCase()!==((o=e.productId)==null?void 0:o.toLowerCase()))return;let i={name:e.path,peripheralId:e.path};this.reportedPorts.set(e.path,e),this.sendRemoteRequest("didDiscoverPeripheral",i),E.default.info(`Discovered serial port -> ${e.path}.`)})}stopDiscover(){this.listPortInterval&&(clearInterval(this.listPortInterval),this.listPortInterval=null),this.discoverTimeout&&(clearTimeout(this.discoverTimeout),this.discoverTimeout=null)}async connect(r){this.stopDiscover();let{peripheralId:t,baudRate:e}=r;if(!t)throw n.invalidParams("missing or invalid port path(peripheralId)").toError();if(!this.reportedPorts.has(t))throw n.invalidParams(`invalid port path(peripheralId): ${t}`).toError();try{await this.portOpen(t,e)}catch(i){throw n.applicationError(`failed to open port: ${i}`).toError()}}async write(r){let{message:t,encoding:e}=r,i=Buffer.from(t,e);try{await this.portWrite(i)}catch(s){throw n.applicationError(`failed to write: ${s}`).toError()}}portOpen(r,t=9600){return new Promise((e,i)=>{this.port=new x.default(r,{autoOpen:!1,baudRate:t},s=>{s&&i(s.message)}),this.port.open(s=>{var o,a;s?i(s.message):(E.default.info(`Serial port ${r} is opened.`),e(),(o=this.port)==null||o.once("error",l=>{E.default.error(`Serial port error: ${l.message}`),this.dispose()}),(a=this.port)==null||a.once("close",()=>{this.dispose()}))})})}portWrite(r){return new Promise((t,e)=>{var i,s;(i=this.port)==null||i.write(r,o=>{o?e(o):t()}),(s=this.port)==null||s.drain(o=>{o?e(o):t()})})}read(r){var s;let{size:t}=r,e=r.encoding?r.encoding.toString():"base64",i=(s=this.port)==null?void 0:s.read(t);return i==null?void 0:i.toString(e)}listen(){var r;(r=this.port)==null||r.on("data",t=>{this.sendRemoteRequest("dataDidChange",{encoding:"base64",message:t.toString("base64")})})}stopListen(){var r;(r=this.port)==null||r.removeAllListeners()}},O=$;O.DiscoverTime=15e3;var T=O;var W=(0,M.createServer)(),V={"/creative/ble":A,"/creative/serialport":T},Y=new H.WebSocketServer({server:W,perMessageDeflate:!1});Y.on("connection",(c,r)=>{let t=new URL(r.url??"/",`ws://${r.headers.host}`),{pathname:e}=t;if(!(e in V)){P.default.error(`Connect unknown path: ${e}.`),c.close();return}P.default.info(`"${e}" is connected.`);let i=new V[e](c),s=()=>{i==null||i.dispose(),i=null,P.default.info(`"${e}" is closed.`)};c.on("close",s),c.on("error",s)});function Z(c){W.listen(c,()=>{P.default.info(`Start elink server on port: ${c}.`)})}module.exports=X(_);0&&(module.exports={startElinkServer});
